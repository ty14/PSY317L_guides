[
["index.html", "PSY317L Guides 1 Welcome to PSY317!", " PSY317L Guides James P. Curley &amp; Tyler M. Milewski June 28, 2020 1 Welcome to PSY317! The following is a simple guide to R studio. "],
["introduction.html", "2 Introduction 2.1 Downloading R 2.2 Downloading RStudio 2.3 Another subheader of something 2.4 Importing Data", " 2 Introduction This chapter details how to get started using R. The initial steps are downloading and installing R. This may differ slightly based on your machine. 2.1 Downloading R Go to the R website. The first box has options for downloading R for Mac, Windows or Linux. Click on the appropriate link. Then you will want to click on \\(\\color{blue}{\\text{&quot;install R for the first time&quot;}}\\). Then follow the instructions. 2.2 Downloading RStudio blah blah blah 2.3 Another subheader of something blah blah blah 2.4 Importing Data There are different options for importing data. It's possible to import data of all different formats into RStudio. We will primarily use spreadsheet type files that have been saved with the &quot;.csv&quot; suffix. These are called 'comma separated files'. Option 1. Import Tab You can click on the &quot;Import Dataset&quot; tab in the top right of RStudio - it's located just above your global environment. Tyler - perhaps we can insert images here? like this Of course, we should look into how to chaneg image sizes. You then need to click on the appropriate file type that you wish to import. As I mentioned, nearly all our files will be &quot;.csv&quot; files, so you should click on &quot;From CSV&quot;. In other versions of RStudio, this may say &quot;from text (readR)&quot; instead. blah blah blah I can't remember how to insert more space between sections, so I just write to try and force space. Option 2. Writing code. This is the option that we will use in our scripts for this course. You may notice that all the datasets that we wish to use are in a folder called &quot;data&quot;. To read in any of these datasets, what we need to do is use the read_csv() function. This comes from a package contained with the tidyverse package, so we must have imported that library first. We then tell it which dataset to find within the 'data' folder. We use the notation &quot;data/...&quot; to tell it to look inside the data folder. For instance, if we wished to load in the bmi.csv dataset, and assign it the name bmi, we would do it like this - make sure to put quotes around the whole file name and location: library(tidyverse) #load package ## -- Attaching packages --------------------------------------- tidyverse 1.2.1 -- ## v ggplot2 3.2.1 v purrr 0.2.4 ## v tibble 2.1.3 v dplyr 0.8.3 ## v tidyr 1.0.2 v stringr 1.3.1 ## v readr 1.1.1 v forcats 0.3.0 ## Warning: package &#39;ggplot2&#39; was built under R version 3.5.3 ## Warning: package &#39;tibble&#39; was built under R version 3.5.3 ## Warning: package &#39;tidyr&#39; was built under R version 3.5.3 ## Warning: package &#39;dplyr&#39; was built under R version 3.5.3 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() bmi &lt;- read_csv(&quot;data/bmi.csv&quot;) # bring in data ## Parsed with column specification: ## cols( ## id = col_integer(), ## age = col_double(), ## bmi = col_double(), ## chol = col_double(), ## insulin = col_double(), ## dbp = col_double(), ## sbp = col_double(), ## smoke = col_integer(), ## educ = col_character() ## ) head(bmi) # first six rows ## # A tibble: 6 x 9 ## id age bmi chol insulin dbp sbp smoke educ ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 1 18.3 15.4 47.2 2.78 29.5 49.7 1 D ## 2 2 19.4 14.5 52.1 3.47 31.3 49.0 2 C ## 3 3 21.1 16.0 52.2 4.06 32.4 51.7 1 B ## 4 4 21.3 19.5 53.2 4.48 32.0 NA 2 A ## 5 5 21.1 18.6 55.4 5.34 33.7 53.8 1 D ## 6 6 23.9 19.5 54.3 6.29 35.0 56.0 2 C Tyler.....Perhaps we should either suppress the warnings and messages (which you can do in the r chunk header in markdown)? Or we should explain what it means when it gets churned out. blah blah blah more stuff. "],
["basic-syntax.html", "3 Basic Syntax 3.1 assignment 3.2 vectors", " 3 Basic Syntax We kind of need to know at least a tiny bit of syntax before we move forward... keep it very simple. 3.1 assignment e.g. what the assignment operator is. This symbol &lt;- which is just a &quot;greater than sign&quot; followed by a &quot;hyphen&quot; is called an assignment operator. It basically is equivalent to saying you want to save something. You write what you want to be saved on the right hand side of it, and the name of your newly saved thing on the left of it. We call the 'thing' that you've saved an 'object' in programming speak. For instance, say you wanted to save the number 17, and you wanted to call that saved number an object called x. You'd do it like this: x &lt;- 17 Now, whenever you type, x, R thinks that it is the number 17. x ## [1] 17 3.2 vectors Of course, you can save even more complex things as the object. For example, if you wished to save the numbers 5, 6, 7, 8, 9, 10, you have two ways of doing that. Let's just see them in action, and then we'll explain the syntax: v1 &lt;- 5:10 v1 ## [1] 5 6 7 8 9 10 v2 &lt;- c(5,6,7,8,9,10) v2 ## [1] 5 6 7 8 9 10 As you can see both v1 and v2 are our newly saved objects and they both contain the numbers 5 through 10. For v1 we separated the numbers 5 and 10 with a colon :. In R, the : sign can be used to mean &quot;to&quot; when talking about a series of numbers. e.g. 5:10 ## [1] 5 6 7 8 9 10 101:103 ## [1] 101 102 103 The other way we did it with v2 was to use the c() function. This stands for concatenate which is a mouthful. Basically, it's a way of sticking things together. You write c() and then put the stuff you want to stick together inside the brackets, but make sure you separate each thing by a comma ,. For example, c(1,10,100,1000) ## [1] 1 10 100 1000 c(4,6,8,10,8,6,1) ## [1] 4 6 8 10 8 6 1 Another bit of terminology might be worth mentioning right now. Our saved objects x, v1 and v2, as well as being called objects can also be called vectors. A vector is something in R that contains several items. These items are actually called elements. Importantly the items are indexed, which means that they are in order, not all jumbled up. That means that you can directly grab an element by it's position. So, if you wished to get the first element (or item) of the object v1 you'd type like this: v1[1] ## [1] 5 That returns '5' which was our first element we put into the vector. If we wish to get the 3rd element of v1 we'd do this: v1[3] ## [1] 7 And, if we wished to get the first, second and third element of v1 we'd do this: v1[1:3] ## [1] 5 6 7 blah blah blah summary image does the image appear above? I just remembered that if you don't want the image to appear inline, then you leave out the ! from the markdown syntax. summary image "],
["introduction-to-data-carpentry.html", "4 Introduction to Data Carpentry 4.1 tidyverse 4.2 filter() 4.3 select() 4.4 arrange() 4.5 mutate()", " 4 Introduction to Data Carpentry What data carpentry is blah blah blah 4.1 tidyverse blah blah blah 4.2 filter() blah 4.3 select() blah 4.4 arrange() blah 4.5 mutate() new column blah blah "],
["data-visualization.html", "5 Data Visualization 5.1 Scatter Plots", " 5 Data Visualization The package ggplot2 is used to visualize data. Before starting you should load the tidyverse package, which includes ggplot2 and other tools, at the very top of your script. See example below. You need to do it once for every script. library(tidyverse) Next you need to read in your data! # {r} # df &lt;- read.csv(&quot;&quot;) # 5.1 Scatter Plots "],
["r-ggplotdf-x-y-geom-point.html", "6 {r} # ggplot(df, (x = , y = )) + # geom_point() #", " 6 {r} # ggplot(df, (x = , y = )) + # geom_point() # "],
["descriptives.html", "7 Descriptives", " 7 Descriptives blah "],
["distributions.html", "8 Distributions", " 8 Distributions blah "],
["confidence-intervals.html", "9 Confidence Intervals", " 9 Confidence Intervals blah "],
["inferential-stats.html", "10 Inferential Stats", " 10 Inferential Stats blah "],
["correlation.html", "11 Correlation 11.1 Pearson Correlation 11.2 Calculating the Pearson Correlation in R 11.3 Cross-products 11.4 Conducting a Pearson Correlation Test 11.5 Assumptions of Pearson's Correlation 11.6 Confidence Intervals for R 11.7 Partial Correlations 11.8 Non-parametric Correlations 11.9 Point-Biserial Correlation", " 11 Correlation intro lines about what correlation is etc... 11.1 Pearson Correlation Pearson's correlation is measured by r and ranges between -1 and +1. +1 indicates that the variables X and Y are maximally positively correlated, such that as values of X increase so do values of Y. -1 indicates a compleltely negative correlation such that as values of X increase, values of Y decrease. A value of 0 indicates that there is no overall relationship. insert figure of negative 0.6, 0 and positive 0.6 here The below image shows scatterplots, each with a sample size of 30. The trendline is to help demonstrate how correlations of different magnitudes look in terms of their association. Correlations 11.2 Calculating the Pearson Correlation in R To calculate the correlation coefficient in R, it's pretty straightforward. You simply can use the cor() function. For instance, let's correlate... cor(1:10,1:10) # replace with an example ## [1] 1 Before we go further into what we should do with these correlations, and how to signficance test them, let's learn a little bit more about how they come about. 11.3 Cross-products The formula for calculating the Pearson's correlation coefficient for a sample is: \\(r = \\frac{\\sum_{}^{} z_{x}z_{y}}{n - 1}\\) When we have a population, we can use the formula: \\(r = \\frac{\\sum_{}^{} z_{x}z_{y}}{N}\\) Essentially, the steps are to convert all the X and Y scores into their respective z-scores. Then you mutliply these two values together to get the cross-product. After summing up all the cross-products for each data point, we divide this number by n-1 if we're dealing with a sample (we usually are), or N if we're dealing with a population. The sum of the cross-products will therefore be largely positive if positive z-scores are multiple together or if negative z-scores are multiplied together. The sum of the cross-products will be largely negative if negative z-scores are multipled with positive z-scores. The following example should help make this clearer. Look at the following data, its scatterplot and the correlation coefficient. They show that we have a positive correlation of r=0.84. Let's break it down how we got that value. x &lt;- c(1.1, 1.5, 2.1, 3.5, 3.6, 3.5, 2.6, 5.6, 4.4, 3.9) y &lt;- c(2.8, 2.9, 1.6, 5.5, 4.7, 8.1, 3.3, 7.7, 7.1, 5.8) df &lt;- data.frame(x, y) df ## x y ## 1 1.1 2.8 ## 2 1.5 2.9 ## 3 2.1 1.6 ## 4 3.5 5.5 ## 5 3.6 4.7 ## 6 3.5 8.1 ## 7 2.6 3.3 ## 8 5.6 7.7 ## 9 4.4 7.1 ## 10 3.9 5.8 ggplot(df, aes(x = x, y = y)) + geom_point(size=2) cor(x,y) ## [1] 0.8418262 First, let's calculate the means and standard deviation (using sd so a sample standard deviation) of x and y. We need to get these values so we can calculate the z-scores of each. # step 1: Get the mean and sd of x and y mean(x) ## [1] 3.18 sd(x) ## [1] 1.370158 mean(y) ## [1] 4.95 sd(y) ## [1] 2.259916 Now, we can calculate the z-scores, remembering that the formula for that is: \\(z = \\frac{x - \\overline{x}}{s_{x}}\\) # step 2. Calculate z-scores of x, and z-scores of y. df$zx &lt;- (x - mean(x)) / sd(x) # z scores of x df$zy &lt;- (y - mean(y)) / sd(y) # z scores of y df ## x y zx zy ## 1 1.1 2.8 -1.5180729 -0.9513626 ## 2 1.5 2.9 -1.2261358 -0.9071132 ## 3 2.1 1.6 -0.7882302 -1.4823557 ## 4 3.5 5.5 0.2335497 0.2433718 ## 5 3.6 4.7 0.3065340 -0.1106236 ## 6 3.5 8.1 0.2335497 1.3938569 ## 7 2.6 3.3 -0.4233088 -0.7301155 ## 8 5.6 7.7 1.7662195 1.2168592 ## 9 4.4 7.1 0.8904082 0.9513626 ## 10 3.9 5.8 0.5254868 0.3761201 Following this, we simply multiple the z-scores of x and y against each other for every data point: # step 3. Calculate the cross-product: zx * zy df$zxzy &lt;- df$zx * df$zy df ## x y zx zy zxzy ## 1 1.1 2.8 -1.5180729 -0.9513626 1.44423785 ## 2 1.5 2.9 -1.2261358 -0.9071132 1.11224399 ## 3 2.1 1.6 -0.7882302 -1.4823557 1.16843751 ## 4 3.5 5.5 0.2335497 0.2433718 0.05683941 ## 5 3.6 4.7 0.3065340 -0.1106236 -0.03390988 ## 6 3.5 8.1 0.2335497 1.3938569 0.32553483 ## 7 2.6 3.3 -0.4233088 -0.7301155 0.30906432 ## 8 5.6 7.7 1.7662195 1.2168592 2.14924036 ## 9 4.4 7.1 0.8904082 0.9513626 0.84710104 ## 10 3.9 5.8 0.5254868 0.3761201 0.19764615 We now have all of our cross-products. Notice why the majority are positive. This is because we have multiplied positive \\(z_{x}\\) with positive \\(z_{y}\\) or we multiplied negative \\(z_{x}\\) with negative \\(z_{y}\\). This happens because datapoints that tend to be above the mean for x are also above the mean for y, and points that are below the mean of x are also below the mean of y. We can add this up to get the sum of the cross-products. That is the \\(\\sum_{}^{} z_{x}z_{y}\\) in the formula. # step 4. Sum up the cross products. sum(df$zxzy) # 7.58 ## [1] 7.576436 We now divide that by n-1 as we have a sample, to get the correlation coefficient r. That gives us an estimation of the average cross-product. # step 5- calculate &#39;r&#39; by dividing by n-1. (for a sample) sum(df$zxzy) / 9 # our n was 10, so n-1 = 9 ## [1] 0.8418262 sum(df$zxzy) / (nrow(df) - 1) # nrow(df) is more generalizable ## [1] 0.8418262 # r=0.84 Just as a quick second example, here is a work through calculating a negative correlation. Notice the \\(z_{x}\\) and \\(z_{y}\\) scores that are multiplied together. They are largely opposite in terms of signs. This is what leads to a negative sum of cross-products and the negative correlation. Why? Because data points that are above the mean for x are generally below the mean in terms of y and visa-versa. ### Example 2. Negative Correlation. x &lt;- c(1.1, 1.5, 2.1, 3.5, 3.6, 3.5, 2.6, 5.6, 4.4, 3.9) y &lt;- c(10.4, 10.0, 8.4, 8.5, 8.4, 6.3, 7.1, 6.2, 8.1, 10.0) df &lt;- data.frame(x, y) ggplot(df, aes(x = x, y = y)) + geom_point(size=2) cor(df$x,df$y) ## [1] -0.6112965 Here is the code, truncated for space: # Calculate z-scores for each x and each y df$zx &lt;- (x - mean(x)) / sd(x) df$zy &lt;- (y - mean(y)) / sd(y) # Calculate the cross-product: zx * zy df$zxzy &lt;- df$zx * df$zy # let&#39;s look at the dataframe # notice the cross products: df ## x y zx zy zxzy ## 1 1.1 10.4 -1.5180729 1.37762597 -2.09133671 ## 2 1.5 10.0 -1.2261358 1.11012578 -1.36116500 ## 3 2.1 8.4 -0.7882302 0.04012503 -0.03162776 ## 4 3.5 8.5 0.2335497 0.10700008 0.02498983 ## 5 3.6 8.4 0.3065340 0.04012503 0.01229968 ## 6 3.5 6.3 0.2335497 -1.36425096 -0.31862038 ## 7 2.6 7.1 -0.4233088 -0.82925058 0.35102907 ## 8 5.6 6.2 1.7662195 -1.43112601 -2.52768263 ## 9 4.4 8.1 0.8904082 -0.16050011 -0.14291061 ## 10 3.9 10.0 0.5254868 1.11012578 0.58335643 # Sum up the cross products and Calculate &#39;r&#39; by dividing by N-1. sum(df$zxzy) / (nrow(df) - 1) ## [1] -0.6112965 cor(df$x,df$y) ## [1] -0.6112965 11.4 Conducting a Pearson Correlation Test Although cor() gives you the correlation between two continuous variables, to actually run a significance test, you need to use cor.test(). Let's use some BlueJay data to do this. We'll just use data on male birds. library(tidyverse) jays &lt;- read_csv(&quot;data/BlueJays.csv&quot;) ## Parsed with column specification: ## cols( ## BirdID = col_character(), ## KnownSex = col_character(), ## BillDepth = col_double(), ## BillWidth = col_double(), ## BillLength = col_double(), ## Head = col_double(), ## Mass = col_double(), ## Skull = col_double(), ## Sex = col_integer() ## ) jayM &lt;- jays %&gt;% filter(KnownSex == &quot;M&quot;) # we&#39;ll just look at Males nrow(jayM) # 63 observations ## [1] 63 head(jayM) ## # A tibble: 6 x 9 ## BirdID KnownSex BillDepth BillWidth BillLength Head Mass Skull Sex ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 0000-00000 M 8.26 9.21 25.9 56.6 73.3 30.7 1 ## 2 1142-05901 M 8.54 8.76 25.0 56.4 75.1 31.4 1 ## 3 1142-05905 M 8.39 8.78 26.1 57.3 70.2 31.2 1 ## 4 1142-05909 M 8.71 9.84 25.5 57.3 74.9 31.8 1 ## 5 1142-05912 M 8.74 9.28 25.4 57.1 75.1 31.8 1 ## 6 1142-05914 M 8.72 9.94 30 60.7 78.1 30.7 1 Let's say you're interested in examining whether there is an association between Body Mass and Head Size. First we'll make a scatterplot between the Mass and Head columns. We'll also investigate the correlation using cor(). ggplot(jayM, aes(x=Mass, y=Head)) + geom_point(shape = 21, colour = &quot;navy&quot;, fill = &quot;dodgerblue&quot;) + stat_smooth(method=&quot;lm&quot;, se=F) cor(jayM$Mass, jayM$Head) # r = 0.58, a strong positive correlation. ## [1] 0.5773562 To run the significance test, we do the following: cor.test(jayM$Head, jayM$Mass) ## ## Pearson&#39;s product-moment correlation ## ## data: jayM$Head and jayM$Mass ## t = 5.5228, df = 61, p-value = 7.282e-07 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.3846090 0.7218601 ## sample estimates: ## cor ## 0.5773562 This gives us a lot of information. Firstly, at the bottom it repeats the correlation coefficient cor. At the top, it gives us the value of t which is essentially how surprising it is for us to get the correlation we did assuming we were drawing our sample from a population where there is no correlation. Associated with this t value is the degrees of freedom which is equal to n-2, so in this case that is 63-2 = 61. The p-value is also given. If we are using alpha=0.05 as our significance level, then we can reject the hypothesis that there is no overall correlation in the population between Body Mass and Head size if p&lt;0.05. The default for cor.test() is to do a two-tailed test. This is testing whether your observed correlation r is different from r=0 in either the positive or negative direction. This default version also gives us the confidence interval for the correlation coefficient. Essentially, this gives us the interval in which we have a 95% confidence that the true population r lies (remember we just have data from one sample that theoretically comes from a population). It's also possible however that you had an a priori prediction about the direction of the effect. For instance, you may have predicted that Body Mass would be positively correlated with Head Size. In this case, you could do a one-tailed correlation test, where your alternative hypothesis is that there is a positive correlation and the null is that the correlation coefficient is equal to 0 or less than 0. To do one-tailed tests you need to add the alternative argument. # testing if there is a positive correlation cor.test(jayM$Head, jayM$Mass, alternative = &quot;greater&quot;) ## ## Pearson&#39;s product-moment correlation ## ## data: jayM$Head and jayM$Mass ## t = 5.5228, df = 61, p-value = 3.641e-07 ## alternative hypothesis: true correlation is greater than 0 ## 95 percent confidence interval: ## 0.4187194 1.0000000 ## sample estimates: ## cor ## 0.5773562 # testing if there is a negative correlation cor.test(jayM$Head, jayM$Mass, alternative = &quot;less&quot;) ## ## Pearson&#39;s product-moment correlation ## ## data: jayM$Head and jayM$Mass ## t = 5.5228, df = 61, p-value = 1 ## alternative hypothesis: true correlation is less than 0 ## 95 percent confidence interval: ## -1.0000000 0.7017994 ## sample estimates: ## cor ## 0.5773562 11.5 Assumptions of Pearson's Correlation The Pearson Correlation Coefficient requires your data to be approximately normally distributed. To do this we have various options how to test for normality. Firstly, we could do a Shapiro-Wilk test, which formally determines whether our data are normal. This is done using shapiro.test(), where we assume our data are from a normal population if the resulting p-value is above 0.05. If the p-value is below 0.05 then we have evidence to reject that our data come from a normal population. With our data above, this would look like this when running the test on each variable: shapiro.test(jayM$Mass) # P &gt; 0.05, therefore cannot reject null that data is not normal ## ## Shapiro-Wilk normality test ## ## data: jayM$Mass ## W = 0.97222, p-value = 0.1647 shapiro.test(jayM$Head) # P &gt; 0.05, therefore cannot reject null that data is not normal ## ## Shapiro-Wilk normality test ## ## data: jayM$Head ## W = 0.96521, p-value = 0.07189 We can also make a QQ-plot for each variable. Essentially what we require from this plot is for the majority of our data to fall on the straight line - especially the datapoints in the middle. Some deviation at the tails is ok. This plot orders our data and plots the observed data against values on the x-axis that we would expect to get if our data was truly from a normal population. qqnorm(jayM$Mass) qqline(jayM$Mass, col = &quot;steelblue&quot;, lwd = 2) qqnorm(jayM$Head) qqline(jayM$Head, col = &quot;steelblue&quot;, lwd = 2) Both of these QQ plots are ok, and indicate normality, as does our Shapiro-Wilk tests. Therefore we would be ok to use a Pearson Correlation test with these data. What should you do though if either of your continuous variables are not approximately normally distributed? In that case, there are other correlation coefficients and associated significance tests that you could run instead. We describe these in more detail in Section x.xxx 11.6 Confidence Intervals for R bit more on this and the theory. 11.7 Partial Correlations why.... the stupid formula.... and how to do in R.... and that there are technically better ways... 11.8 Non-parametric Correlations examples.... 11.9 Point-Biserial Correlation why, what.... "],
["regression.html", "12 Regression", " 12 Regression blah "],
["permutation-testing.html", "13 Permutation Testing", " 13 Permutation Testing An example of permutation testing and the theory behind it. e.g. a correlation permutation test e.g. a 2 sample t-test permutation test. "]
]
